use parity_wasm::elements::{External, FunctionType, ImportSection, Module, Type, ValueType};

//pub trait ModuleValidator {
//    fn validate(self, module: &Module) -> Result<bool, String>;
//}
//
//pub struct CheckNumericInstruction {
//	numeric_instruction_verified: bool,
//}
//
//fn check_numeric_instruction(f: Func) -> bool {
//	unimplemented!();
//}
//
//impl ModuleValidator for CheckNumericInstruction {
//	fn validate(self, module: &Module) -> Result<bool, String> {
//		match module.function_section() {
//			Some(functions) => {
//				match functions {
//					Some(function) => check_numeric_instruction(function),
//					None => unimplemented!(),
//				}
//			},
//			None => unimplemented!(),
//		}
//	}
//}

#[cfg(test)]
mod tests {
	use super::*;
	use parity_wasm::elements::deserialize_buffer;

    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }

	#[test]
	fn print_instructions_simple_binary() {
		let wasm: Vec<u8> = vec![
			0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x07, 0x01, 0x60, 0x02, 0x7f, 0x7f, 0x01,
			0x7f, 0x03, 0x02, 0x01, 0x00, 0x0a, 0x09, 0x01, 0x07, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6a, 0x0b,
			0x00, 0x14, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x02, 0x0d, 0x01, 0x00, 0x02, 0x00, 0x03, 0x6c, 0x68,
			0x73, 0x01, 0x03, 0x72, 0x68, 0x73,
		];

		let module = deserialize_buffer::<Module>(&wasm).unwrap();

		match module.code_section() {
			Some(section) => {
				for function in section.bodies() {
					println!("{:?}", function.code().elements());
				}
			}
			None => println!("No Functions")
		}
	}

	#[test]
	fn print_instructions_complex_binary() {
		let wasm: Vec<u8> = vec![
			0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x87, 0x80, 0x80, 0x80, 0x00, 0x01, 0x60,
			0x02, 0x7f, 0x7f, 0x01, 0x7f, 0x03, 0x84, 0x80, 0x80, 0x80, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04,
			0x84, 0x80, 0x80, 0x80, 0x00, 0x01, 0x70, 0x00, 0x00, 0x05, 0x83, 0x80, 0x80, 0x80, 0x00, 0x01,
			0x00, 0x01, 0x06, 0x81, 0x80, 0x80, 0x80, 0x00, 0x00, 0x07, 0xaf, 0x80, 0x80, 0x80, 0x00, 0x04,
			0x06, 0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x02, 0x00, 0x09, 0x5f, 0x5a, 0x34, 0x6d, 0x75, 0x6c,
			0x74, 0x69, 0x69, 0x00, 0x00, 0x08, 0x5f, 0x5a, 0x33, 0x61, 0x64, 0x64, 0x69, 0x69, 0x00, 0x01,
			0x0b, 0x5f, 0x5a, 0x36, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x69, 0x69, 0x00, 0x02, 0x0a, 0xa5,
			0x80, 0x80, 0x80, 0x00, 0x03, 0x87, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x01, 0x20, 0x00, 0x6c,
			0x0b, 0x87, 0x80, 0x80, 0x80, 0x00, 0x00, 0x20, 0x01, 0x20, 0x00, 0x6a, 0x0b, 0x87, 0x80, 0x80,
			0x80, 0x00, 0x00, 0x20, 0x00, 0x20, 0x01, 0x6d, 0x0b
		];

		let module = deserialize_buffer::<Module>(&wasm).unwrap();

		match module.code_section() {
			Some(section) => {
				for function in section.bodies() {
					println!("{:?}", function.code().elements());
				}
			}
			None => println!("No Functions")
		}
	}
}
